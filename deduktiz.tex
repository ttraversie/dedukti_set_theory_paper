\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{LFMTP 2022} % Name of the event you are submitting to
%\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{underscore}           % Only needed if you use pdflatex.

\title{An Implementation of Set Theory with Pointed Graphs in Dedukti}
\author{Valentin Blot
\institute{Inria, France\\
LMF, ENS Paris-Saclay, France}
\email{valentin.blot@inria.fr}
\and
Gilles Dowek
\institute{Inria, France\\
LMF, ENS Paris-Saclay, France}
\email{gilles.dowek@ens-paris-saclay.fr}
\and
Thomas Traversi√©
\institute{CentraleSup√©lec, France}
\email{thomas.traversie@inria.fr}
}

\def\titlerunning{An Implementation of Set Theory with Pointed Graphs in Dedukti}
\def\authorrunning{V. Blot, G. Dowek, T. Traversi√©}

%% My packages

\usepackage{tikz}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%% Lambdapi code

\usepackage{listings}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{xcolor}
\definecolor{green}{RGB}{0,130,0}
\definecolor{lightgrey}{RGB}{240,240,240}

\lstdefinelanguage{Lambdapi}
{
  inputencoding=utf8,
  extendedchars=true,
  numbers=none,
  numberstyle={},
  tabsize=2,
  basicstyle={\ttfamily\upshape\mdseries},
  backgroundcolor=\color{lightgrey},
  keywords={abort,admit,admitted,apply,as,assert,assertnot,associative,assume,begin,builtin,commutative,compute,constant,debug,end,fail,flag,focus,generalize,have,in,induction,inductive,infix,injective,left,let,notation,off,on,opaque,open,prefix,print,private,proofterm,protected,prover,prover_timeout,quantifier,refine,reflexivity,require,rewrite,right,rule,sequential,simplify,solve,symbol,symmetry,type,TYPE,unif_rule,verbose,why3,with},
  sensitive=true,
  keywordstyle=\color{blue},
  morecomment=[l]{//},
  commentstyle={\itshape\color{red}},
  string=[b]{"},
  stringstyle=\color{orange},
  showstringspaces=false,
  literate=
  {‚Ü™}{$\hookrightarrow$}1
  {‚Üí}{$\rightarrow$}1
  {Œ†}{$\Pi$}1
  {‚âî}{\quad $\coloneqq$}1
  {ùîπ}{$\mathbb{B}$}1
  {ùïÉ}{$\mathbb{L}$}1
  {‚Ñï}{$\mathbb{N}$}1
  {Œ±}{$\alpha$}1
  {Œª}{$\lambda$}1
  {œÉ}{$\sigma$}1
  {œÄ}{$\pi$}1
  {œÑ}{$\tau$}1
  {œâ}{$\omega$}1
  {‚àß}{$\wedge$}1
  {‚à®}{$\vee$}1
  {‚â§}{$\le$}1
  {‚â†}{$\neq$}1
  {‚àâ}{$\notin$}1
  {√ó}{$\times$}1
  {œÅ}{$\rho$}1
  {‚àà}{$\in$}1
  {‚àÄ}{$\forall$}1
  {‚àÉ}{$\exists$}1
  {‚áí}{$\Rightarrow$}1
  {‚áî}{$\Leftrightarrow$}1
  {‚ä§}{$\top$}1
  {‚ä•}{$\bot$}1
}
\lstset{language={Lambdapi}}

%% Macro

\def\Type{\mbox{\tt TYPE}}
\def\Kind{\mbox{\tt KIND}}
\def\ra{\rightarrow}
\def\lra{\longrightarrow}
\def\Set{\mbox{\it Set}}
\def\bliota{{ind}}
\def\El{{\mbox{\it El}}}
\def\Prop{{\mbox{\it Prop}}}
\def\imp{\mathbin{\Rightarrow}}
\def\fa{{\forall}}
\def\bltop{{\top}}
\def\blbot{{\bot}}
\DeclareMathOperator{\blneg}{{\neg}}
\def\conj{\mathbin{\wedge}}
\def\disj{\mathbin{\vee}}
\def\ex{{\exists}}

\newtheorem{theorem}{Theorem}[section]

\newenvironment{proof}{\noindent {\em Proof.}}{\medskip}

\newcommand{\dedukti}{\textsc{Dedukti}}
\newcommand{\lpcm}{$\lambda \Pi\textit{-calculus modulo theory}$}

\def\Graph{{\mbox{\it Graph}}}
\def\Node{{\mbox{\it Node}}}
\def\omicron{{\mbox{\it omicron}}}
\def\arr{{\mbox{\it arrow}}}

%%%%%%%%%%%%

\begin{document}
\maketitle

\begin{abstract}
\dedukti ~is a type-checker for the \lpcm, a logical framework that allows the extension of conversion with user-defined rewrite rules. In this paper, we present the implementation of a version of Dowek-Miquel's intuitionistic set theory in \dedukti. To do so, we adapt this theory -- based on the concept of pointed graphs -- from \textit{Deduction modulo theory} to \lpcm, and we \textit{formally} write the proofs in \dedukti. In particular, this implementation requires the definition of a deep embedding of a certain class of formulas, as well as its interpretation in the theory.
\end{abstract}

\section{Introduction}

During the last decades, theorem provers have attracted a lot of interest from various fields of science. Especially, the use of such tools has become more and more common in the areas of software verification and formalization of mathematics. As an example, verification has become mandatory for software running on aircrafts, and formalization of mathematical results allowed the scientific community to trust some complicated proofs of recent results, as well as identify and fix errors in some cases.

This growing interest has triggered the developement of many theorem provers, with various focuses and based on a large range of theories. While the diversity of theorem provers provides users with a wide range of tools, this comes at the expense of a lack of interaction and reusability between proof fragments done in different tools. The \lpcm ~is a logical framework supporting dependent types and user-definable rewrite rules, and \dedukti ~\cite{expressing} is a type-checker for this framework. The definition of well-chosen rewrite rules allows the encoding of various logics, and hence the translations between various theorem provers through the \dedukti ~tool.

Several theorem provers, such as \textsc{Mizar}, \textsc{Atelier B} and \textsc{Isabelle/ZF}, are based on set theory. In order to extend the interoperability allowed by \dedukti ~to these provers, it is necessary to encode set theory in the \lpcm, and to implement this encoding in \dedukti. The goal of this paper is to present such an encoding and implementation. In order to facilitate the proof of its correctness, we implement this encoding in the tool \textsc{Lambdapi} that provides tactics to help the user in the production of proofs type-checkable in \dedukti.

Stating each axiom of set theory in \dedukti ~would lead to an implementation that does not satisfy a cut-elimination theorem. In particular, it would forbid extraction of witnesses from constructive existence proofs.

An alternative option would be to orient these axioms as rewriting rules. For instance the powerset axiom $x \in \mathcal{P}(y) \Leftrightarrow x \subseteq y$ would be replaced with the rewrite rule $x \in \mathcal{P}(y) \lra x \subseteq y$. However, as pointed out by Crabb√©~\cite{crabbe}, such a formulation of set theory does not satisfy a cut-elimination property either. Indeed, if for a given set $a$ we define the set $b\equiv\{x\in a\,|\,x\in x\}$ then $b\in b$ would get rewritten to $b\in a\wedge b\in b$, leading to an infinite reduction.

In the current paper, we represent sets as \textit{pointed graphs} \cite{pointed}. With such a formulation, we can prove a cut-elimination theorem: for every proof in natural deduction there exists a cut-free proof of the same statement. Such an encoding of set theory has been defined in the context of \textit{Deduction modulo theory}~\cite{zermodulo}, together with pencil and paper proofs. At that time, the \lpcm ~had not been defined yet, and the first contribution of the current paper is to adapt this encoding to the \lpcm. In particular, we avoid the original definition of classes of nodes by using the quantification on propositions permitted by \lpcm. This reduces the size of the signature from 31 to 26 symbols.

The second contribution consists in the implementation of this new theory in \dedukti. In the original formulation of the theory some lemmas are only valid for a specific class of formulas, as their proofs proceed by induction on the structure of these formulas. Implementing these lemmas in \dedukti ~requires the definition of an inductive sort of formulas together with an interpretation of these formulas into the general type of propositions. This interpretation is defined with rewriting rules. The current development is the first, to our knowledge, to use such a reflection principle defined with rewriting rules in \dedukti. The generality of this method still remains to be investigated.

\section{The Theory of Pointed Graphs}

The set theory with pointed graphs developed by Dowek and Miquel is called Intuitionistic Zermelo set theory in \textit{Deduction modulo} (IZmod). We give here an informal presentation of the ideas developed in \cite{zermodulo}.

\subsection{Sets as Pointed Graphs}

\label{informal}

In the IZmod theory, sets are represented by pointed graphs, that is, direct graphs with a distinguished node: the root. We give here the representation of several sets as pointed graphs. The root is indicated by the filled circle. The location of the root is important as it changes the set represented by the pointed graph, distinct pointed graphs represent the same set. For example, in the third graph, the node $b$ is irrelevant since the root is $c$.

\begin{figure}[h]
\centering
\begin{tikzpicture}[>=stealth,yscale=1.8,xscale=1.35]  

\node(h1) at (3,3.5)[text centered]{$\emptyset$};
\node(a) at (3,3)[circle,draw,text centered,fill=gray] {a};
\node(h2) at (4,3.5)[text centered]{$\{\emptyset\}$};
\node(b) at (4,3)[circle,draw,text centered,fill=gray] {b};
\node(c) at (4,2.5)[circle,draw,text centered] {c};
\node(h3) at (5,3.5)[text centered]{$\emptyset$};
\node(b1) at (5,3)[circle,draw,text centered] {b};
\node(c1) at (5,2.5)[circle,draw,text centered,fill=gray] {c};
\node(h3) at (6.5,3.5)[text centered]{$\{\emptyset,\{\emptyset\}\}$};
\node(d) at (6.5,3)[circle,draw,text centered,fill=gray] {d};
\node(e) at (6,2.5)[circle,draw,text centered] {e};
\node(f) at (7,2.5)[circle,draw,text centered] {f};
\node(g) at (7,2)[circle,draw,text centered] {g};
\node(h4) at (8.5,3.5)[text centered]{$\emptyset$};
\node(d1) at (8.5,3)[circle,draw,text centered] {d};
\node(e1) at (8,2.5)[circle,draw,text centered,fill=gray] {e};
\node(f1) at (9,2.5)[circle,draw,text centered] {f};
\node(g1) at (9,2)[circle,draw,text centered] {g};
\node(h5) at (10.5,3.5)[text centered]{$\{\emptyset\}$};
\node(d2) at (10.5,3)[circle,draw,text centered] {d};
\node(e2) at (10,2.5)[circle,draw,text centered] {e};
\node(f2) at (11,2.5)[circle,draw,text centered,fill=gray] {f};
\node(g2) at (11,2)[circle,draw,text centered] {g};
\node(h6) at (12.5,3.5)[text centered]{$\emptyset$};
\node(d3) at (12.5,3)[circle,draw,text centered] {d};
\node(e3) at (12,2.5)[circle,draw,text centered] {e};
\node(f3) at (13,2.5)[circle,draw,text centered] {f};
\node(g3) at (13,2)[circle,draw,text centered,fill=gray] {g};
                      
\draw[->] (b) -- (c); 
\draw[->] (b1) -- (c1); 
\draw[->] (d) -- (e);
\draw[->] (d) -- (f);
\draw[->] (f) -- (g);
\draw[->] (d1) -- (e1);
\draw[->] (d1) -- (f1);
\draw[->] (f1) -- (g1);
\draw[->] (d2) -- (e2);
\draw[->] (d2) -- (f2);
\draw[->] (f2) -- (g2);
\draw[->] (d3) -- (e3);
\draw[->] (d3) -- (f3);
\draw[->] (f3) -- (g3);

\end{tikzpicture}
\end{figure}

IZmod has a sort of pointed graphs and a sort of nodes. If $a$ is a pointed graph, $root(a)$ is the root of $a$, which is a node. If $x$ is a node of $a$, then $a/x$ denotes the pointed graph $a$ where the root has been replaced with $x$. If $y$ is also a node of $a$, $x~\eta_a~y$ is the proposition asserting that there is a edge in $a$ from $y$ to $x$. Following this interpretation, IZmod contains the following rewriting rules:
$$ x \ \eta_{a/z} \ y \longrightarrow x \ \eta_a \ y \qquad\qquad root(a/x) \longrightarrow x \qquad\qquad (a/x)/y \longrightarrow a/y $$

As noted above, distinct pointed graphs can represent the same set. Two pointed graphs representing the same set are related through a notion of bisimilarity, denoted $\simeq$, and defined with the rewrite rule:

\begin{equation*}
\begin{split}
a \simeq b \lra~\ex r,~ &r~root(a)~root(b) \\
&\conj \ \fa x \fa x'~\fa y~(x'~\eta_a~x~\conj~r~x~y~\imp~\ex y'~(y'~\eta_b~y~\conj~r~x'~y')) \\
&\conj \ \fa y \fa y'~\fa x~(y'~\eta_b~y~\conj~r~x~y~\imp~\ex x'~(x'~\eta_a~x~\conj~r~x'~y')))
\end{split}
\end{equation*}

As an example, the following pointed graphs are bisimilar, hence they represent the same set:

\begin{figure}[h]
\centering
\begin{tikzpicture}[>=stealth,yscale=1.8,xscale=1.4]  

\node(b) at (5,3)[circle,draw,text centered,fill=gray] {b};
\node(c) at (5,2.5)[circle,draw,text centered] {c};
\node(d) at (7,3)[circle,draw,text centered] {d};
\node(e) at (6.5,2.5)[circle,draw,text centered] {e};
\node(f) at (7.5,2.5)[circle,draw,text centered,fill=gray] {f};
\node(g) at (7.5,2)[circle,draw,text centered] {g};
\node(h) at (5.75,2.75)[text centered]{$\simeq$};
                      
\draw[->] (b) -- (c); 
\draw[->] (d) -- (e);
\draw[->] (d) -- (f);
\draw[->] (f) -- (g);

\end{tikzpicture}
\end{figure}

In set theory, there only exists one sort: the sets. The IZmod theory has two sorts: nodes and pointed graphs, and two notions related to set membership: relations between pointed graphs and relations between nodes within the same graph. As an example, take $\emptyset \in \{\emptyset\}$:

\begin{figure}[h]
\centering
\begin{tikzpicture}[>=stealth,yscale=1.8,xscale=1.4]  

\node(d) at (6,3)[circle,draw,text centered] {k};
\node(e) at (6,2.5)[circle,draw,text centered,fill=gray] {$\ell$};
\node(k) at (6.5,2.75)[text centered]{$\in$};
\node(f) at (7,3)[circle,draw,text centered,fill=gray] {k};
\node(g) at (7,2.5)[circle,draw,text centered] {$\ell$};
                      
\draw[->] (d) -- (e);
\draw[->] (f) -- (g);

\end{tikzpicture}
\end{figure}

Since there is an edge from $k$ to $\ell$, the set represented by the pointed graph with root $\ell$ is an element of the set represented by the pointed graph with root $k$. But any pointed graph bisimilar to the pointed graph with root $\ell$ also represents a set that is an element of the set represented by the pointed graph with root $k$. This leads to the definition of a membership relation $\in$ with the rewrite rule:
$$a \in b \lra \ex x~(x~\eta_b~root(b)~\conj~a \simeq (b/x))$$

In order to define set constructions such as pairs or powersets, we need a way of \textit{joining} two existing graphs together, as well as a way of adding a new node to an existing graph. To this end, the IZmod theory has two disjoint injections $i$ and $j$ on nodes, and a symbol for some constant node $o$ that is not in the image of $i$ or $j$. There are also inverses $i'$ and $j'$ to $i$ and $j$, and predicates $I$ and $J$ on the images of $i$ and $j$:
\begin{align*}
i'(i(x)) &\lra x &\qquad\qquad I(i(x)) &\lra \top &\qquad\qquad I(j(x)) &\lra \bot &\qquad\qquad I(o) \lra \bot\\
j'(j(x)) &\lra x &\qquad\qquad J(j(x)) &\lra \top &\qquad\qquad J(i(x)) &\lra \bot &\qquad\qquad J(o) \lra \bot
\end{align*}

\subsection{Set Theories}

The membership $\in$ and bisimilarity $\simeq$ relations define a set theory IZst that lies between Zermelo (Z) and Zermelo-Fraenkel (ZF). This theory does not include the Replacement scheme but it contains two additional axioms: Strong Extensionality and Transitive Closure:\\

\textbf{Strong Extensionality axiom.} 
\begin{equation*}
\begin{split}
\fa x_1...\fa x_n\fa a\fa b~ &(R(a, b) \\
&\conj~\fa x\fa x'\fa y~(x' \in x \conj R(x, y) \imp \ex y'~(y' \in y \conj R(x', y'))) \\
&\conj~\fa y\fa y'\fa x~(y' \in y \conj R(x, y) \imp \ex x'~(x' \in x \conj R(x', y'))) \\
&\imp a \simeq b) 
\end{split}
\end{equation*}

where $R(a,b)$ is a formula with free variables $x_1, ..., x_n$. Note that the hypothesis of the Strong Extensionality axiom mimics the structure of the rewrite rule for $\simeq$.
%This can be explained with the following reasoning: in the Extensionality axiom, the hypothesis states that two sets have the same elements, so the hypothesis of the strong extensionality axiom copy the structure of one of the equivalent to the inclusion in IZmod --that is to say the constructor $\eta$.
\\

\textbf{Transitive Closure axiom.} $\fa a\ex e~(a \subseteq e \conj \fa x\fa y~(x \in y \conj y \in e \imp x \in e))$ \\

The Transitive Closure axiom conveys the idea that every set is included in a transitive set. \\

Strong Extensionality can be deduced from Foundation and Transitive Closure can be derived from Replacement. Moreover, Strong Extensionality implies Extensionality\footnote{See Section \ref{extensionality}}. Therefore we have the following picture:

%The IZmod theory is an extension of IZst set theory with an encoding of pointed graphs.


\begin{center}
\begin{tikzpicture}[>=stealth,yscale=1,xscale=1]  

\draw[rounded corners=3pt] (0.5,0.5) rectangle (4,5);
\draw[rounded corners=3pt] (0.25,0.25) rectangle (8,5.25);
\draw[rounded corners=3pt] (0,0) rectangle (12,5.5);

\node(a) at (2.25,3)[text width=3cm,text centered] {\underline{\textbf{Z}} \\ Pairing \\ Union \\ Extensionality \\ Powerset \\ Comprehension \\ Infinity};
\node(b) at (6,3)[text width=10cm,text centered] {\underline{\textbf{IZst}} \\ Strong Extensionality \\ Transitive Closure};
\node(c) at (10,3)[text width=3cm,text centered] {\underline{\textbf{ZF}} \\ Foundation \\ Replacement};

\end{tikzpicture}
\end{center}

\section{The Language of Pointed Graphs}

\subsection{Sorts}

There are four sorts in IZmod \cite[see Section 3.2]{zermodulo}: graphs, nodes, classes of nodes and binary relations between nodes. We implemented the first two via the standard technique~\cite{theoryU} of defining a universe $\Set:\Type$ of sorts, a function $\El$ of type $\Set \ra \Type$ and two constants $graph$ and $node$ of type $\Set$:
\begin{lstlisting}
constant symbol graph : Set;
constant symbol node : Set;
\end{lstlisting}
We also introduce a constant $\arr $ of type $\Set \ra \Set \ra \Set$, together with its associated rewrite rule $\El~(x~\arr~y) \lra (\El~x) \ra (\El~y)$.

Contrary to deduction modulo, classes of nodes and binary relations on nodes can be expressed primitively via quantifications on propositions in \lpcm. The sort of classes is defined in \dedukti ~as $\El~node \ra \El~prop$ and that of binary relations as $\El~node \ra \El~node \ra \El~prop$.

The symbols $graph$ and $node$ are specific to the expression of IZmod in \dedukti, while in contrast the symbols $\Set$, $\El$ and $prop$ are part of the standard library of \dedukti.

\subsection{Signature}

The signature of IZmod contains 31 symbols \cite[see Table 2]{zermodulo}. As we have replaced the sorts for classes and relations with primitive \dedukti ~types, we do not need specific predicate symbols $mem$ and $rel$ to apply a class to a node or a relations to two. By virtue of the encoding of classes of nodes as elements of $\El~node \ra \El~prop$, $mem(x,P)$ can simply be expressed as $P~x$, and similarly $rel(x,y,r)$ can simply be expressed as $r~x~y$. In the same way, we do not need symbols $g_{x,y_1,...,y_n,P}$ and $g'_{x,x',y_1,...,y_n,P}$ to build classes and relations. Finally, the equality symbol is part of the standard library of \dedukti. The signature is thus reduced to 26 symbols. Below are the first 25 symbols, the specific case of the comprehension symbol is treated later.

\begin{lstlisting}
symbol eta : El graph ‚Üí El node ‚Üí El node ‚Üí El prop;
symbol root : El graph ‚Üí El node;
symbol cr : El graph ‚Üí El node ‚Üí El graph; // change of root

constant symbol o : El node;
symbol i : El node ‚Üí El node;
symbol i' : El node ‚Üí El node;
symbol j : El node ‚Üí El node;
symbol j' : El node ‚Üí El node;
symbol I : El node ‚Üí El prop;
symbol J : El node ‚Üí El prop;

// injection from graphs to nodes (for powerset) and its inverse
symbol œÅ : El graph ‚Üí El node;
symbol œÅ' : El node ‚Üí El graph;

// natural numbers
constant symbol O : El node;
symbol Succ : El node ‚Üí El node;
symbol Pred : El node ‚Üí El node;
symbol Null : El node ‚Üí El prop;
symbol Nat : El node ‚Üí El prop;
symbol < : El node ‚Üí El node ‚Üí El prop;

symbol simeq : El graph ‚Üí El graph ‚Üí El prop; // bisimilarity
symbol ‚àà : El graph ‚Üí El graph ‚Üí El prop;
symbol join : El graph ‚Üí El graph;
symbol pair : El graph ‚Üí El graph ‚Üí El graph;
symbol powerset : El graph ‚Üí El graph;
symbol omega : El graph; // set of natural numbers
symbol closure : El graph ‚Üí El graph;
\end{lstlisting}

\subsection{Rewriting Rules}

Among the rewrite rules \cite[see Table 3]{zermodulo}, we can drop the compatibility of equality with $mem$ as it comes for free with the Leibniz equality of \dedukti's standard library. We can also drop the rewrite rules determining the behavior of $g_{x,y_1,...,y_n,P}$ and $g'_{x,x',y_1,...,y_n,P}$, as they are superseeded by our encoding of classes and binary relations. The remaining rewrite rules are easy to implement in \dedukti:
\filbreak
\begin{center}
\underline{\textbf{General}}
\end{center}
\begin{lstlisting}
rule eta (cr $a $z) $x $y ‚Ü™ eta $a $x $y;
rule root (cr $a $x) ‚Ü™ $x;
rule (cr (cr $a $x) $y) ‚Ü™ cr $a $y;
\end{lstlisting}
\filbreak
\begin{center}
\underline{\textbf{Relocations}}
\end{center}
\begin{lstlisting}
rule i' (i $x) ‚Ü™ $x;
rule j' (j $x) ‚Ü™ $x;
rule œÅ' (œÅ $x) ‚Ü™ $x;
rule I (i $x) ‚Ü™ ‚ä§;
rule J (j $x) ‚Ü™ ‚ä§;
rule I (j $x) ‚Ü™ ‚ä•;
rule J (i $x) ‚Ü™ ‚ä•;
rule I (o) ‚Ü™ ‚ä•;
rule J (o) ‚Ü™ ‚ä•;

rule Pred (Succ $x) ‚Ü™ $x ;
rule Null O ‚Ü™ ‚ä§;
rule Nat O ‚Ü™ ‚ä§;
rule Null (Succ $x) ‚Ü™ ‚ä•;
rule Nat (Succ $x) ‚Ü™ Nat $x;

rule $x < O ‚Ü™ ‚ä•;
rule $x < (Succ $y) ‚Ü™ ($x < $y) ‚à® ($x = $y);
\end{lstlisting}
\filbreak
\begin{center}
\underline{\textbf{Equality and Membership}}
\end{center}
\begin{lstlisting}
rule $a simeq $b ‚Ü™ `‚àÉ r : El (node arrow (node arrow prop)), 
    r (root $a) (root $b)
    ‚àß (`‚àÄ x, `‚àÄ x', `‚àÄ y, 
        eta $a x' x ‚àß r x y
            ‚áí `‚àÉ y', eta $b y' y ‚àß r x' y')
    ‚àß (`‚àÄ y, `‚àÄ y', `‚àÄ x, 
        eta $b y' y ‚àß r x y
            ‚áí `‚àÉ x', eta $a x' x ‚àß r x' y');

rule $a ‚àà $b ‚Ü™ `‚àÉ x, ((eta $b x (root $b)) ‚àß ($a simeq cr $b x));
\end{lstlisting}
\filbreak
\begin{center}
\underline{\textbf{Constructions}}
\end{center}
\begin{lstlisting}
rule eta (join $a) $x $x' ‚Ü™ 
	(`‚àÉ y, `‚àÉ y', ($x = i y) ‚àß ($x' = i y') ‚àß eta $a y y')
    ‚à® (`‚àÉ y, `‚àÉ z, ($x = i y) 
    	‚àß ($x' = o) 
    	‚àß eta $a y z 
    	‚àß eta $a z (root $a));

rule eta (pair $a $b) $x $x' ‚Ü™ 
	(`‚àÉ y, `‚àÉ y', (($x = i y) ‚àß ($x' = i y') ‚àß eta $a y y'))
    ‚à® (`‚àÉ y, `‚àÉ y', ($x = j y) ‚àß ($x' = j y') ‚àß eta $b y y')
    ‚à® (($x = i (root $a)) ‚àß ($x' = o))
    ‚à® (($x = j (root $b)) ‚àß ($x' = o));

rule eta (powerset $a) $x $x' ‚Ü™ 
	(`‚àÉ y, `‚àÉ y', ($x = i y) ‚àß ($x' = i y') ‚àß eta $a y y')
    ‚à® (`‚àÉ y, `‚àÉ c, ($x = i y) 
    	‚àß ($x' = j (œÅ c)) 
    	‚àß (eta $a y (root $a)) 
    	‚àß ((cr $a y) ‚àà c))
    ‚à® (`‚àÉ c, ($x = j (œÅ c)) ‚àß ($x' = o));

rule eta omega $x $x' ‚Ü™ 
	(`‚àÉ y, `‚àÉ y', ($x = i y) ‚àß ($x' = i y') ‚àß (y < y'))
    ‚à® (`‚àÉ y, ($x = i y) ‚àß ($x' = o) ‚àß Nat y);

rule eta (closure $a) $x $x' ‚Ü™ 
	(`‚àÉ y, `‚àÉ y', (($x = i y) ‚àß ($x' = i y') ‚àß eta $a y y'))
	‚à® (`‚àÉ y, ($x = i y) 
        ‚àß ($x' = o)
        ‚àß (`‚àÄ c : El (node arrow prop), 
                ((`‚àÄ z, eta $a z (root $a) ‚áí c z)
                ‚àß (`‚àÄ z, `‚àÄ z', (eta $a z z') ‚àß (c z') ‚áí (c z)))
            ‚áí c y));
            
rule root (join $a) ‚Ü™ o;
rule root (pair $a $b) ‚Ü™ o;
rule root (powerset $a) ‚Ü™ o;
rule root omega ‚Ü™ o;
rule root (closure $a) ‚Ü™ o;
\end{lstlisting}

The pointed graph \texttt{omega} represents the set of Von Neumann ordinals \cite[see Table 2]{zermodulo}. Indeed, the rewriting rule of \texttt{eta omega x x'} states that in \texttt{omega} the edges correspond to the order relation $<$ and that there is an edge from every natural number to the root of \texttt{omega}. Therefore, the elements of \texttt{omega} are the natural numbers, and the elements of some natural number are all the natural numbers stricly below it, which corresponds to the definition of Von Neumann ordinals.


\section{The Language of Formulas}

This section is devoted to the operator that builds sets by comprehension. Indeed, in IZmod, the only valid sets of the form $\{x\in a\,|\,P(x)\}$ are those for which $P$ does not contain elements specific to the implementation of sets as pointed graphs, that is, all quantifiers in $P$ must be on $graph$ and $P$ can only use symbols $\in$, $\simeq$ and the logical connectives \cite[see Table 5]{zermodulo}. Taking this restriction into account is the main challenge of our implementation. In order to achieve this goal, we define a datatype representing the class of formulas just described, as well as an interpretation of this datatype into $El~prop$.

\subsection{Formulas}

We define the constant $formula$ of type $\Set$ and the operators for building elements of $El~formula$. Variables are represented as natural numbers and we do not need to handle $\alpha$-conversion as we do not need substitution.

\begin{lstlisting}
constant symbol formula : Set;
constant symbol eqF : El nat ‚Üí El nat ‚Üí El formula;
constant symbol inF : El nat ‚Üí El nat ‚Üí El formula;
constant symbol andF : El formula ‚Üí El formula ‚Üí El formula;
constant symbol orF : El formula ‚Üí El formula ‚Üí El formula;
constant symbol allF : El nat ‚Üí El formula ‚Üí El formula;
constant symbol exF : El nat ‚Üí El formula ‚Üí El formula;
constant symbol impF : El formula ‚Üí El formula ‚Üí El formula;
constant symbol fF : El formula;
constant symbol tF : El formula;
\end{lstlisting}

We also define an induction principle over formulas:

\begin{lstlisting}
constant symbol recF : Œ† (P : El formula ‚Üí Prop), 
œÄ(`‚àÄ x, `‚àÄ y, P (eqF x y))
‚Üí œÄ(`‚àÄ x, `‚àÄ  y, P (inF x y))
‚Üí œÄ(`‚àÄ f, `‚àÄ g, (P f ‚àß P g) ‚áí (P (andF f g)))
‚Üí œÄ(`‚àÄ f, `‚àÄ g, (P f ‚àß P g) ‚áí (P (orF f g)))
‚Üí œÄ(`‚àÄ f, `‚àÄ g, (P f ‚àß P g) ‚áí (P (impF f g)))
‚Üí œÄ(`‚àÄ f, (P f) ‚áí (`‚àÄ x, P (allF x f)))
‚Üí œÄ(`‚àÄ f, (P f) ‚áí (`‚àÄ x, P (exF x f)))
‚Üí œÄ(P tF)
‚Üí œÄ(P fF)
‚Üí œÄ(`‚àÄ f, P f);
\end{lstlisting}

\subsection{Interpretation}

In this section, we define the interpretation of the datatype of formulas into the type of propositions. Since formulas can contain variables (represented as natural numbers), the interpretation depends on a valuation from natural numbers to graphs. Hence we have:

\begin{lstlisting}
symbol interpretation : (El nat ‚Üí El graph) ‚Üí El formula ‚Üí El prop;
\end{lstlisting} 

The interpretation of quantifiers requires an operator for updating a valuation, taking as arguments the initial valuation, the variable that needs to be updated, and the new value of this variable:

\begin{lstlisting}
symbol update : (El nat ‚Üí El graph) ‚Üí El nat ‚Üí El graph
                                         ‚Üí (El nat ‚Üí El graph)
\end{lstlisting} 

The computation of $update~\sigma~x~a~y$ relies on a decision procedure for the equality on natural numbers: if $x=y$ then $update~\sigma~x~a~y$ is $a$, other wise it is $\sigma~y$. Rather than implementing such a decision procedure separately, we embed it in an auxiliary function:

\begin{lstlisting}
symbol update1 : (El nat ‚Üí El graph) ‚Üí El nat ‚Üí El graph ‚Üí El nat
                                         ‚Üí (El nat ‚Üí El graph)
\end{lstlisting} 

$update~\sigma~x~a~y$ reduces to $update1~\sigma~x~a~y~y$, and $update1~\sigma~x~a~y~z$ reduces to $a$ if $x=y$, and $\sigma~z$ otherwise, by decreasing $x$ and $y$ until one (or both) becomes $zero$. The last argument to $update1$ is thus used for storing the variable at which $update~\sigma~x~a$ was initially called. The rewrite rules are as follows:

\begin{lstlisting}
rule update $œÉ $x $a $y ‚Ü™ update1 $œÉ $x $a $y $y;
rule update1 $œÉ zero $a zero $z ‚Ü™ $a;
rule update1 $œÉ zero $a (s $y) $z ‚Ü™ $œÉ $z;
rule update1 $œÉ (s $x) $a zero $z ‚Ü™ $œÉ $z;
rule update1 $œÉ (s $x) $a (s $y) $z ‚Ü™ update1 $œÉ $x $a $y $z;
\end{lstlisting}

We can prove that $update$ and $update1$ satisfy the intended properties:

\begin{theorem}
\begin{equation*}
\begin{split}
\fa \sigma \fa x \fa y \fa z \fa a ~((x = y \ \imp \ update1 \ \sigma \ x \ a \ y \ z \ = \ a) \ \conj \ (\blneg \ x = y \ \imp \ update1 \ \sigma \ x \ a \ y \ z \ = \ \sigma \ z))
\\
\fa \sigma \fa \sigma' \fa x \fa a \fa b~ (a \ \simeq \ b \ \imp \ (\fa y~ (\sigma \ y \ \simeq \ \sigma' \ y)) \ \imp \ \fa z~ (update \ \sigma \ x \ a \ z \ \simeq \ update \ \sigma' \ x \ b \ z))
\end{split}
\end{equation*}
\end{theorem}

Now we have all the tools to define the rewriting rules of the interpretation of formulas:

\begin{lstlisting}
rule interpretation $œÉ (eqF $x $y) ‚Ü™ ($œÉ $x) simeq ($œÉ $y);
rule interpretation $œÉ (inF $x $y) ‚Ü™ ($œÉ $x) ‚àà ($œÉ $y);
rule interpretation $œÉ (andF $f $g)
                ‚Ü™ (interpretation $œÉ $f) ‚àß (interpretation $œÉ $g);
rule interpretation $œÉ (orF $f $g)
                ‚Ü™ (interpretation $œÉ $f) ‚à® (interpretation $œÉ $g);
rule interpretation $œÉ (impF $f $g)
                ‚Ü™ (interpretation $œÉ $f) ‚áí (interpretation $œÉ $g);
rule interpretation $œÉ (allF $x $f)
                ‚Ü™ `‚àÄ a, interpretation (update $œÉ $x a) $f;
rule interpretation $œÉ (exF $x $f)
                ‚Ü™ `‚àÉ a, interpretation (update $œÉ $x a) $f;
rule interpretation $œÉ fF ‚Ü™ ‚ä•;
rule interpretation $œÉ tF ‚Ü™ ‚ä§;
\end{lstlisting}

We can finally prove that $interpretation$ is invariant under $\simeq$-equivalent valuations:

\begin{theorem}
$\fa f \fa \sigma \fa \sigma' ~((interpretation \ \sigma \ f \ \conj \ \fa x ~(\sigma \ x \ \simeq \ \sigma' \ x)) \ \imp \ interpretation \ \sigma' \ f)$
\end{theorem}
\begin{proof}
By induction over formula f. $\square$
\end{proof}

\subsection{Comprehension, Empty Set and Inductive Set}

With this syntax for restricted formulas at hand together with the interpretation in $prop$, we are finally able to define the comprehension construction in \dedukti:

\begin{lstlisting}
symbol comp : El graph ‚Üí (El nat ‚Üí El graph) ‚Üí El formula
                                                       ‚Üí El graph;
\end{lstlisting}

together with its rewrite rules

\begin{lstlisting}
rule eta (comp $a $œÉ $f) $x $x' ‚Ü™ 
	(`‚àÉ y, `‚àÉ y', (($x = i y) ‚àß ($x' = i y') ‚àß eta $a y y')) 
	‚à® (`‚àÉ y, ($x = i y) ‚àß ($x' = o) ‚àß (eta $a y (root $a))
	‚àß (interpretation (update $œÉ zero (cr $a y)) $f));
rule root (comp $a $œÉ $f) ‚Ü™ o;
\end{lstlisting}

When it comes to the symbol related to the Infinity section of \cite[see Section 2.1]{zermodulo}, we implement $empty\_set$ of type $\El~graph$ and $Ind$ of type $\El~graph \ \ra \ \El~prop$.

Using comprehension with the set of natural numbers and the formula $fF$ gives the empty set:
\begin{lstlisting}
rule empty_set ‚Ü™ comp omega (Œª _, omega) fF;
\end{lstlisting}

and we can define inductive sets:

\begin{lstlisting}
rule Ind $c ‚Ü™ (empty_set ‚àà $c) 
‚àß (`‚àÄ a, (a ‚àà $c) ‚áí ((join (pair a (pair a a))) ‚àà $c));
\end{lstlisting}

\section{Lemmas}

A first result on the original formulation of the theory was to prove that the axioms of IZst are theorems in IZmod. This required 53 lemmas that were \textit{informally} proved in \cite[see Tables 4 and 5]{zermodulo} and that we prove \textit{formally} in this paper.

Some of these proofs just follow the informal ones. Some others require the use of the type of formula and its embedding into propositions. 

The first lemma $x=x$ does not need to be implemented since it is already part of the standard library of \dedukti \ under the name \texttt{refl} (which is polymorphic).

The second lemma is already a consequence of the rewriting rule of the polymorphic $=$ implemented in the standard library of \dedukti: 
\begin{lstlisting}
constant symbol = [s] : El s ‚Üí El s ‚Üí El prop;
notation = infix 4;
rule œÄ (@= $s $x $y) ‚Ü™ Œ† (P : El $s ‚Üí El prop), œÄ(P $x) ‚Üí œÄ(P $y);
\end{lstlisting}

All the other lemmas of IZmod except the ones where $comp$ is involved are proved using the blueprint in \cite[see Proposition 1]{zermodulo53}. The complete proofs can be found in \url{https://github.com/Deducteam/dedukti_set_theory/}.

\subsection{An Example of Proof}

To show the way lemmas are proved in \dedukti ~we will take the example of lemma 30 and comment its proof. This lemma states that $$ a \in b \conj a \simeq c \imp c \in b $$

\begin{proof}
We first assume graphs $a$, $b$ and $c$ and $H$ the proof of $ a \in b \conj a \simeq c $. $a \in b$ rewrites to $\ex x~(x~\eta_b~root~b \conj a \simeq (b/x))$. 

We make appear $x$ and $Hx$ the proof $x~\eta_b~root~b \conj a \simeq (b/x)$. 

As the goal is to prove $c \in b$, that is to say $\ex y~(y~\eta_b~root~b \conj c \simeq (b/y))$, we need to find a suitable $y$. We take $x$ and now have two goals: $y~\eta_b~root~b$ and $c \simeq (b/y)$. 

The first one is proved by applying the left part of $Hx$. 

The second one is obtained by applying lemma 5 to $c$, $a$ and $b/x$. To apply lemma 5, we need to prove $c \simeq a \imp a \simeq b/x$. $c \simeq a$ is proved applying reflexivity to $a \simeq c$ (i.e. applying lemma 4 to $a$, $c$ and the right part of $H$). $a \simeq b/x$ derives from the right part of $Hx$. $\square$
\end{proof}

This proof is written in \dedukti ~with the following code: 

\begin{lstlisting}
opaque symbol lemma30 : œÄ(`‚àÄ a, `‚àÄ b, `‚àÄ c, 
	((a ‚àà b) ‚àß (a simeq c)) ‚áí (c ‚àà b))
‚âî begin
assume a b c H;
refine ex_e node _ (and_el _ _ H) _ _;
assume x Hx;
refine ex_i node x _ _;
refine and_i _ _ _ _
{refine and_el _ _ Hx}
{refine lemma5 c a (cr b x) 
	(and_i _ _ (lemma4 a c (and_er _ _ H)) (and_er _ _ Hx))}
end;
\end{lstlisting}

\subsection{Lemmas involving Formulas}

Now that the language of formulas have been designed along with the implementation of the $comp$ symbol, lemma 32 can be implemented.

$$(P(z \leftarrow a) \conj a \simeq b) \imp P(z \leftarrow b)$$

We implement it thanks to the $interpretation$ symbol. The valuation $update~\sigma~z~a$ represents the assignment of variable $z \leftarrow a$.

\begin{lstlisting}
opaque symbol lemma32 : Œ† (z : El nat), Œ† (f : El formula), 
	œÄ(`‚àÄ a, `‚àÄ b, (`‚àÄ œÉ : (El nat ‚Üí El graph),
	((interpretation (update œÉ z a) f) ‚àß (a simeq b)) 
	‚áí (interpretation (update œÉ z b) f)))
\end{lstlisting}

The proof of this \texttt{opaque symbol} is done by induction over formulas: each case is proved easily, using the lemmas that have already been checked by \dedukti. \\

Lemma 41 is implemented similarly:

\begin{lstlisting}
opaque symbol lemma41 : Œ† (x y : El nat), Œ† (f : El formula), 
	Œ† (c d : El graph), œÄ(`‚àÄ œÉ : (El nat ‚Üí El graph), 
	((interpretation (update (update œÉ x c) y d) f)
	‚àß (`‚àÄ a, `‚àÄ a', `‚àÄ b, 
		((a' ‚àà a) 
		‚àß (interpretation (update (update œÉ x a) y b) f)) 
		‚áí (`‚àÉ b', ((b' ‚àà b) 
			‚àß (interpretation (update (update œÉ x a') y b') f))))
	‚àß (`‚àÄ b, `‚àÄ b', `‚àÄ a, 
		((b' ‚àà b) 
		‚àß (interpretation (update (update œÉ x a) y b) f)) 
		‚áí (`‚àÉ a', ((a' ‚àà a) 
			‚àß (interpretation (update (update œÉ x a') y b') f))))) 
	‚áí (c simeq d))
\end{lstlisting}

\subsection{Weak Extensionnality}

\label{extensionality}

We notice in \cite{zermodulo53} the use of weak extensionality (simply called extensionality) to prove lemmas 44, 47 and 48. We want to deduce weak extensionality from strong extensionality (i.e. lemma 41). \\

\textbf{Weak extensionality.} $\fa c\fa d~ (\fa z~ (z \in c \Leftrightarrow z \in d) \imp c \simeq d)$ \\

We follow the blueprint given by G. Dowek and A. Miquel \cite[see Proposition 1]{zermodulo} : we use the strong extensionality axiom where $R(x,y)$ is $(x \simeq c~\conj~y \simeq d)~\disj~x \simeq y$. \\

\begin{proof}
We want to prove that $\fa c\fa d~(\fa z~ (z \in c \Leftrightarrow z \in d) \imp c \simeq d)$. We assume that $\fa z~ (z \in c \Leftrightarrow z \in d)$. We want to apply strong extensionality to deduce $c \simeq d$. To do so, we need to prove the three terms of the hypothesis of strong extensionality.

$(c \simeq c~\conj~d \simeq d)~\disj~c \simeq d$ is a tautology.

We want to prove that $\fa a\fa a'\fa b~(a' \in a~\conj~((a \simeq c~\conj~b \simeq d)~\disj~a \simeq b) \imp (\ex b'~ (b' \in b~\conj~((a' \simeq c~\conj~b' \simeq d)~\disj~a' \simeq b'))$. We assume $(a' \in a~\conj~((a \simeq c~\conj~b \simeq d)~\disj~a \simeq b)$. If $(a \simeq c~\conj~b \simeq d)$, then we choose $b' \simeq a'$. We have $b' \in a$ because $a' \in a$. Yet, $a \simeq c$, $c \simeq d$ and $d \simeq b$. Then $b' \in b$. If $a \simeq b$, we choose $b' \simeq a'$. We have $b' \in a$ because $a' \in a$. Yet, $a \simeq b$. Thus $b' \in b$.

We proceed similarly for the third term. $\square$
\end{proof}

We implement this theorem in \dedukti:

\begin{lstlisting}
opaque symbol lemmaHypExt : Œ† (c d : Graph), 
	œÄ((`‚àÄ z, (z ‚àà c) ‚áî (z ‚àà d)) ‚áí 
	((((c simeq c) ‚àß (d simeq d)) ‚à® (c simeq d))
	‚àß (`‚àÄ a, `‚àÄ a', `‚àÄ b, 
		((a' ‚àà a) ‚àß (((a simeq c) ‚àß (b simeq d)) ‚à® (a simeq b))) 
		‚áí (`‚àÉ b', ((b' ‚àà b) 
		‚àß (((a' simeq c) ‚àß (b' simeq d)) ‚à® (a' simeq b')))))
	‚àß (`‚àÄ b, `‚àÄ b', `‚àÄ a, 
		((b' ‚àà b) ‚àß (((a simeq c) ‚àß (b simeq d)) ‚à® (a simeq b)))
		 ‚áí (`‚àÉ a', ((a' ‚àà a) 
	 	‚àß (((a' simeq c) ‚àß (b' simeq d)) ‚à® (a' simeq b')))))))
\end{lstlisting}

To prove $weak \ extensionality$, we assume graphs $c$ and $d$, and $H$ the hypothesis $\fa z~ (z \in c) \Leftrightarrow (z \in d)$. Then we apply lemma 41 to:

\begin{itemize}
\item natural numbers $zero$ and $one$
\item the formula $(orF~(andF~(eqF~zero~two)~(eqF~one~three))~(eqF~zero~one))$
\item graphs $c$ and $d$
\item the valuation $(update~(update~(\lambda \_, empty\_set)~two~c)~three~d)$ 
\item the proof of the left hand term $lemmaHypExt~c~d~H$.
\end{itemize}

Indeed, in the formula $$(orF~(andF~(eqF~zero~two)~(eqF~one~three))~(eqF~zero~one))$$ $zero$ and $one$ will be interpreted by $c$ and $d$ thanks to lemma 41 and $two$ will be interpreted by $c$ and $three$ by $d$ thanks the valuation $$(update~(update~(\lambda \_, empty\_set)~two~c)~three~d)$$ The proposition obtained corresponds to the proposition in lemmaHypExt.


\begin{lstlisting}
opaque symbol lemmaExt : Œ† (c d : El graph), 
	œÄ((`‚àÄ x, (x ‚àà c) ‚áî (x ‚àà d)) ‚áí (c simeq d))
‚âî begin
assume c d H;
refine lemma41 zero one 
	(orF (andF (eqF zero two) (eqF one three)) (eqF zero one)) 
	c d (update (update (Œª _, empty_set) two c) three d) 
	(lemmaHypExt c d H)
end;
\end{lstlisting}

\subsection{The Axioms of IZst Theory}

We have now encoded in \dedukti ~all the axioms of IZst set theory: the strong extensionality axiom corresponds to lemma 41, the axiom of the union is implemented by lemma 42, the pairing axiom corresponds to lemma 43, the axiom of the power set is encoded by lemma 44, the comprehension scheme is implemented by lemma 45, the axiom of infinity corresponds to lemma 51 and the transitive closure axiom is encoded by lemmas 52 and 53.


\section{Conclusion}

We have implemented in \dedukti ~a version of set theory -- IZst -- that corresponds to Zermelo set theory, with the Strong Extensionality axiom and the Transitive Closure axiom. To do so, we have adapted the work by G. Dowek and A. Miquel \cite{zermodulo} from \textit{Deduction modulo theory} to \lpcm ~and have encoded sets with a structure of pointed graphs of the IZmod theory. We have \textit{formally} written all the proofs of the lemmas allowing us to implement set theory in \dedukti.

To define and prove the lemmas corresponding to the Comprehension axiom, we have developed a language of formulas, along with operators \textit{interpretation} and \textit{update}. In particular, the language of formulas allows us to prove that the Extensionality axiom derives from the Strong Extensionality axiom.

Historically, the encoding of sets by pointed graphs had been designed to enjoy the normalization property. IZmod expressed in \textit{Deduction modulo theory} does so, but the case of our implementation in \lpcm ~remains to be investigated.

The implementation of IZmod theory represents a significant corpus of formal proofs in \textsc{Lambdapi}.

\newpage
\section*{Annex}

\begin{center}
\begin{tabular}{|c|c||c|c|}
\hline Lemma & Number of lines in the proof & Lemma & Number of lines in the proof \\
\hline 3 & 26 & 29 & 17 \\
\hline 4 & 14 & 30 & 10 \\
\hline 5 & 37 & 31 & 12 \\
\hline 6 & 33 & 32 & 49 \\
\hline 7 & 12 & 33 & 33 \\
\hline 8 & 5 & 34 & 33 \\
\hline 9 & 12 & 35 & 9 \\
\hline 10 & 12 & 36 & 9 \\
\hline 11 & 5 & 37 & 9 \\
\hline 12 & 5 & 38 & 9 \\
\hline 13 & 5 & 39 & 9 \\
\hline 14 & 37 & 40 & 9 \\
\hline 15 & 40 & 41 & 42 \\
\hline 16 & 48 & Weak extensionality & 47 \\
\hline 17 & 48 & 42 & 49 \\
\hline 18 & 38 & 43 & 39 \\
\hline 19 & 44 & 44 & 133 \\
\hline 20 & 90 & 45 & 46 \\
\hline 21 & 34 & 46 & 11 \\
\hline 22 & 35 & 47 & 18 \\
\hline 23 & 34 & 48 & 165 \\
\hline 24 & 38 & 49 & 11 \\
\hline 25 & 31 & 50 & 23 \\
\hline 26 & 38 & 51 & 6 \\
\hline 27 & 29 & 52 & 17 \\
\hline 28 & 33 & 53 & 31 \\
\hline
\end{tabular}
\end{center}




%\nocite{*}
\bibliographystyle{eptcs}
\bibliography{biblio}
\end{document}
